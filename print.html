<!DOCTYPE HTML>
<html lang="zh-Hans" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JVM Specification (Java SE 17 Edition) Chinese Translation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="chap02/structure_of_jvm.html"><strong aria-hidden="true">2.</strong> JVM的结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chap02/class_file_format.html"><strong aria-hidden="true">2.1.</strong> class文件格式</a></li><li class="chapter-item expanded "><a href="chap02/data_type.html"><strong aria-hidden="true">2.2.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="chap02/primitive_type.html"><strong aria-hidden="true">2.3.</strong> 原子类型</a></li><li class="chapter-item expanded "><a href="chap02/reference_type.html"><strong aria-hidden="true">2.4.</strong> 引用类型</a></li><li class="chapter-item expanded "><a href="chap02/runtime_data_area.html"><strong aria-hidden="true">2.5.</strong> 运行时数据区域</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JVM Specification (Java SE 17 Edition) Chinese Translation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第一章-介绍"><a class="header" href="#第一章-介绍">第一章 介绍</a></h1>
<h2 id="历史"><a class="header" href="#历史">历史</a></h2>
<p>Java编程语言是一种通用的、并发的、面向对象的语言语言。它的语法类似于C和C++，但它省去了许多使C和C++变得复杂、混乱和不安全的特性。Java平台被开发，最初是用于解决构建网络设备的软件的问题。它被设计为支持多主机架构，并允许软件组件的安全交付。为了满足这些要求，编译后的代码必须满足要在跨网络传输中存活，在任何客户端上操作，并确保客户端是安全运行的目标。</p>
<p>万维网的普及使这些特性更加明显有趣。网络浏览器使数百万人能够以简单的方式上网并且访问丰富的媒体内容。终于有了一种媒介不管你使用的是哪种机器，无论连接的是快速的网络还是慢的调制解调器，看到和听到的内容基本上是相同的。</p>
<p>Web爱好者很快就发现了由Web的HTML所支持的内容文档格式太有限。HTML扩展，比如表单强调了这些限制，同时明确指出没有浏览器可以包含所有用户想要的功能。可扩展性是答案。</p>
<p><a href="https://zh.wikipedia.org/wiki/HotJava">HotJava</a>浏览器首先展示了Java编程语言和平台使程序嵌入在HTML页面成为可能的有趣的特性（译者注：<a href="https://zh.wikipedia.org/wiki/Java_applet">Java Applet</a>）。程序和HTML页面被透明地下载到浏览器中，并且呈现在HTML页面中。在被浏览器接受之前，程序被仔细检查，以确保是安全的。像HTML页面，编译后的程序是独立于网络和主机的。这些程序不管来自哪里或使用哪种机器加载和运行，它们都表现出相同的行为。</p>
<p>与Java平台结合的Web浏览器不再局限于预先确定的功能集。访问者访问包含动态内容的网页可以确保其机器不会被该内容损坏。程序员只需要编写一次程序，就可以在任何提供Java运行时环境的机器上运行（译者注：Write once, run anywhere）。</p>
<h2 id="java虚拟机"><a class="header" href="#java虚拟机">Java虚拟机</a></h2>
<p>Java虚拟机是Java平台的基石。这是负责硬件和操作系统独立性的技术组件，其编译代码的体积小，且具有保护用户免受恶意程序的侵害的能力。</p>
<p>Java虚拟机是一个抽象的计算机。就像真正的计算一样机器，它有一个指令集，并在运行时操作各种内存区域。使用虚拟机来实现编程语言是相当常见的；最著名的虚拟机可能是<a href="https://zh.wikipedia.org/wiki/UCSD_Pascal">UCSD Pascal</a> 的 <a href="https://zh.wikipedia.org/wiki/P-code%E6%9C%BA">P-Code</a>虚拟机。</p>
<p>Java虚拟机的第一个原型实现，在 <a href="https://zh.wikipedia.org/wiki/%E6%98%87%E9%99%BD%E9%9B%BB%E8%85%A6">Sun Microsystems</a>公司完成， 在软件中模拟了Java虚拟机指令集，该软件由一个类似于当代个人数码设备(<a href="https://zh.wikipedia.org/wiki/%E4%B8%AA%E4%BA%BA%E6%95%B0%E7%A0%81%E5%8A%A9%E7%90%86">PDA</a>)的手持设备托管。Oracle当前的实现模拟了Java虚拟机在移动端，桌面端和服务器端的设备，但Java虚拟机不限定（not assume）任何特定的实现技术、主机硬件或主机操作系统。它不是固有的解释型的（ It is not inherently interpreted），但也可以通过将其指令集编译为处理器（silicon CPU）的指令集来实现。也可能可以在微指令（<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E7%A8%8B%E5%BA%8F">microcode</a>）或者硬件（silicon）中实现。</p>
<p>Java虚拟机对Java编程语言一无所知，仅针对特定的二进制格式，<code>class</code>文件格式。其中<code>class</code>文件包含Java虚拟机指令(或字节码(<em>bytecodes</em>))和符号表等辅助信息。</p>
<p>为了安全起见，对于<code>class</code>文件的代码，Java虚拟机引入了强大的语法和结构约束。然而，任何可以通过合法的<code>class</code>文件表示功能的语言都可以被托管到Java虚拟机（hosted by)。被一种普遍可用的、与机器无关的平台的特性所吸引的开发者，都可以转向Java虚拟机，将其作为他们语言的传递工具（Groovy，Kotlin）。</p>
<p>这里指定的Java虚拟机与Java SE 17平台兼容，并支持 <a href="https://docs.oracle.com/javase/specs/jls/se17/html/index.html"><em>The Java Language Specification, Java SE 17 Edition</em></a>中指定的Java编程语言。</p>
<h2 id="内容组织"><a class="header" href="#内容组织">内容组织</a></h2>
<p>第2章概述了Java虚拟机架构。</p>
<p>第3章介绍了用Java编程语言编写的代码编译成Java虚拟机指令的过程。</p>
<p>第4章具体说明与硬件和操作系统无关用于表示已编译类和接口的二进制格式的<code>class</code>文件格式。</p>
<p>第5章具体说明Java虚拟机的启动，加载、链接和初始化类和接口。</p>
<p>第6章具体说明Java虚拟机的指令集，以操作码助记符的字母顺序来展示指令。</p>
<p>第7章给出了一个以操作码值为索引的Java虚拟机操作码助记符表。</p>
<p>在第二版的<em>Java Virtual Machine Specification</em>，第2章概述了 Java 编程语言，旨在支持
Java 虚拟机规范，但它本身并不是规范的一部分。在<em>Java Virtual Machine Specification, Java SE 17 Edition</em>（译者注：也就是本手册）中，请读者参阅<a href="https://docs.oracle.com/javase/specs/jls/se17/html/index.html"><em>The Java Language Specification, Java SE 17 Edition</em></a>来查询Java编程语言相关信息。引用的格式：(JLS§x.y)指出需要这样做的地方。</p>
<p>在第二版的Java虚拟机规范，第8章详细解释了具有共享主存的Java虚拟机线程交互的底层操作。在<em>Java Virtual Machine Specification, Java SE 17 Edition</em>中，读者可以参考<a href="https://docs.oracle.com/javase/specs/jls/se17/html/index.html"><em>The Java Language Specification, Java SE 17 Edition</em></a>的第17章有关线程和锁的信息。第17章反映了出自于JSR133专家组的<a href="https://www.cs.umd.edu/%7Epugh/java/memoryModel/jsr133.pdf">The Java Memory Model and Thread Specification</a>。</p>
<h2 id="符号"><a class="header" href="#符号">符号</a></h2>
<p>在整个规范中，我们指出的类和接口取自Java SE平台API。当我们引用一个类或接口时(除了那些声明在示例中的)，使用单个标识符<em>N</em>，其指的是<code>java.lang</code>包中的类或接口。在<code>java.lang</code>包以外的类或者接口，我们使用全限定名（fully qualified name）来指明。</p>
<p>每当我们引用一声明在<code>java</code>或它的任何子包中的类或者接口时，预期的引用是那个类或者接口被启动类加载器加载(<a href="https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-5.html#jvms-5.3.1">§5.3.1</a>)。</p>
<p>每当我们引用一个名为<code>java</code>的包的子包时，预期的引用是由启动类装加载器决定的。</p>
<p>本规范中字体的使用如下:</p>
<ul>
<li><code>等宽</code>字体用于Java虚拟机数据类型、异常、错误、<code>class</code>文件结构、<a href="https://zh.wikipedia.org/wiki/Prolog">Prolog</a>代码和Java代码片段。</li>
<li><em>斜体</em>是用于Java虚拟机的“汇编语言”，其操作码和操作数，以及Java虚拟机的运行时数据区域中的项。它也用于介绍新的术语和简单的强调。</li>
</ul>
<p>非规范性信息，旨在澄清规范，使用以下格式表示：</p>
<blockquote>
<p>这是非规范性信息。 它提供直觉、基本原理、建议、示例等。</p>
</blockquote>
<h2 id="反馈"><a class="header" href="#反馈">反馈</a></h2>
<p>读者可以报告<em>Java Virtual Machine Specification</em>中的技术错误和歧义，反馈至jls-jvms-spec-comments@openjdk.java.net（译者注：由于译者水平有限，此翻译可能存在不准确，反馈时请自行阅读原版规范确定无误后再反馈）。</p>
<p>关于<code>javac</code>（Java编程语言的参考编译器）生成和操作<code>class</code>文件的问题可以发送到compilerdev@openjdk.java.net（译者注：由于译者水平有限，此翻译可能存在不准确，反馈时请自行阅读原版规范确定无误后再反馈）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jvm的结构"><a class="header" href="#jvm的结构">JVM的结构</a></h1>
<p>这个文档具体说明了一个抽象机器。它没有描述任何特定的Java虚拟机的实现。</p>
<p>要正确实现Java虚拟机，您只需要能够读取<code>class</code>文件格式并正确执行其中指定的操作。不属于Java虚拟机规范的实现细节没必要限制实现者的创造力。例如，运行时数据区域的内存布局、使用的垃圾收集算法以及任何Java虚拟机指令的内部优化(例如，将它们翻译成机器代码)是由实现者决定的。</p>
<p>本规范中对Unicode的所有引用都是关于<em>The Unicode Standard, Version 13.0</em>，可在 https://www.unicode.org/ 获得。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="class文件格式"><a class="header" href="#class文件格式"><code>class</code>文件格式</a></h2>
<p>由 Java 虚拟机执行的编译代码表示为一种独立于硬件和操作系统的二进制格式，通常（但不是必须）存储在一个文件中，称为<code>class</code>文件格式。 <code>class</code>文件格式精确定义类或接口的表示，包括细节，例如在特定于平台的目标文件中可能被视为理所当然的字节顺序（<a href="https://en.wikipedia.org/wiki/Endianness">Byte Ordering</a>）。</p>
<p>第 4 章，”<code>class</code>文件格式“，详细介绍了<code>class</code>文件格式。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<p>与 Java 编程语言一样，Java 虚拟机在两种类型上进行操作：<em>原子类型（primitive types）<em>和</em>引用类型（reference types）</em>。相应地，有两种类型的值可以被存储在变量中，作为参数传递，作为方法返回值被返回，并可以对其进行操作：<em>原子类型的值（primitive values）<em>和</em>引用类型的值（reference values）</em>。</p>
<p>Java 虚拟机期望几乎所有类型检查都在运行前完成，通常这是由编译器完成的，而不必由 Java 完成虚拟机本身完成。原子类型的值不需要被标记（tagged）或以其他方式检查以确定它们在运行时的类型，或与引用类型的值进行区分。取而代之的是Java虚拟机的使用那些操作在特定类型上的指令来区分操作数类型。例如，<em>iadd</em>、<em>ladd</em>、<em>fadd</em> 和 <em>dadd</em> 都是 Java 虚拟机将两个数值相加并产生数值结果的指令，但每一个都是专门针对其操作数类型：分别为<code> int</code>、<code>long</code>、<code>float</code> 和 <code>double</code>。对于Java虚拟机指令集支持的类型的总结，请参阅 §2.11.1。</p>
<p>Java 虚拟机包含对对象的显式支持。一个对象是动态分配的类实例或数组。对对象的引用被认为时 Java 虚拟机引用（<code>reference</code>）类型。<code>reference</code>类型的值可以被认为是指向对象的指针。总是通过<code>reference</code>类型的值来操作、传递和测试对象。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="原子类型"><a class="header" href="#原子类型">原子类型</a></h2>
<p>Java 虚拟机支持的原子数据类型是数字类型（<em>numeric types</em>）、布尔类型(<code>boolean</code> type)（第 2.3.4 节）和 <code>returnAddress</code> 类型（第 2.3.3 节）。</p>
<p>数字类型由整数类型（<em>integral types</em>）（第 2.3.1 节）和浮点类型（<em>floating-point types</em>）组成（§2.3.2）。</p>
<p>整数类型包括：</p>
<ul>
<li><code>byte</code>，它的值时8位有符号二进制补码整数，默认值为0。</li>
<li><code>short</code>，它的值时16位有符号二进制补码整数，默认值为0。</li>
<li><code>int</code>，它的值时32位有符号二进制补码整数，默认值为0。</li>
<li><code>long</code>，它的值时64位有符号二进制补码整数，默认值为0。</li>
<li><code>char</code>，它的值时16位<strong>无符号</strong>整数表示的在<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">基本多文种平面</a>Unicode码点（code point），使用UTF-16编码，默认值是空码点（<code>\u0000</code>）。</li>
</ul>
<p>浮点类型包括：</p>
<ul>
<li><code>float</code>它的值与<a href="https://en.wikipedia.org/wiki/IEEE_754#Basic_and_interchange_formats">IEEE 754 binary32</a>格式的相对应，默认值是<strong>正数0</strong>（+0）</li>
<li><code>double</code>，它的值与<a href="https://en.wikipedia.org/wiki/IEEE_754#Basic_and_interchange_formats">IEEE 754 binary64</a>格式的相对应，默认值是<strong>正数0</strong>（+0）</li>
</ul>
<p><code>boolean</code>类型的值编码真值是<code>true</code>和<code>false</code>，默认值是<code>false</code>。</p>
<blockquote>
<p>第一版的<em>The Java Virtual Machine Specification</em>没有将<code>boolean</code>类型视为一种Java虚拟机类型。然而，<code>boolean</code>值在Java虚拟机中有受限的支持。第二版的<em>The Java Virtual Machine Specification</em>将<code>boolean</code>视为一种类型来阐明这个问题。</p>
</blockquote>
<p><code>returnAddress</code> 类型的值是指向 Java虚拟机指令的操作码的指针。 在原子类型中，只有 <code>returnAddress</code> 类型不是直接与 Java 编程语言类型相关联。</p>
<h3 id="整数类型和值"><a class="header" href="#整数类型和值">整数类型和值</a></h3>
<p>Java虚拟机的整数类型的值为：</p>
<ul>
<li>对于<code>byte</code>，范围为-128~127（\(-2^7\)~\(2^7-1\)），包含-128和127</li>
<li>对于<code>short</code>，范围为-32768~32767（\(-2^15\)~\(2^15-1\)），包含-32768和32767</li>
<li>对于<code>int</code>，范围为-2147483648 ~2147483647（\(-2^31\)~\(2^31-1\)），包含-2147483648和2147483647</li>
<li>对于<code>long</code>，范围为-9223372036854775808~9223372036854775807（\(-2^63\)~\(2^63-1\)），包含-9223372036854775808和9223372036854775807</li>
<li>对于<code>char</code>，范围为0~65535，包含0和65535</li>
</ul>
<h3 id="浮点类型和值"><a class="header" href="#浮点类型和值">浮点类型和值</a></h3>
<p>浮点类型有<code>float</code>和<code>double</code>，它们在概念上分别和IEEE 754 中的32位binary32和64位binary64浮点数格式的值和操作相关联(JLS§1.7)。</p>
<blockquote>
<p>在Java SE 15及之后的版本中，Java虚拟机使用IEEE 754的2019版标准。在Java SE 15之前，Java虚拟机使用的是1985版的IEEE  754标准，其中binary32格式被称为单精度（single format），binary64格式被称为双精度（double format）。</p>
</blockquote>
<p>IEEE 754不仅包括由符号和绝对值（<a href="https://simple.wikipedia.org/wiki/Magnitude_(mathematics)#:%7E:text=The%20magnitude%20of%20a%20real%20number%20is%20usually,absolute%20value%20or%20modulus.%20It%20is%20written%20as"><em>magnitude</em></a>）组成的正数和负数，还有正零和负零，正无穷大和负无穷大(<em>infinities</em>)，和特殊的非数值的值(Not-a-Number)(以下简称NaN)。NaN值为用于表示某些无效运算的结果，如0除以0。<code>float</code>和<code>double</code>类型的NaN常量被预定义为<code>Float.NaN</code>和<code>Double.NaN</code>。</p>
<p>有限的非零的浮点数类型的值可以被表示为\(s\cdot m \cdot 2^{(e-N+1)}\) ，这里的：</p>
<ul>
<li>\(s\) 是 +1 或者 -1，</li>
<li>\(m\) 是一个小于 \(2^N\) 的正整数，</li>
<li>\(e\) 是一个整数，满足\(E_{min}\le e \le E_{max}\) ，其中 \(E_{min}=-(2^{K-1}-2)\) ，\(E_{max}=2^{K-1}-1\) ，</li>
<li>\(N\) 和 \(K\) 是依赖于类型的参数</li>
</ul>
<p>有些值可以以多种方式表示为这种形式。例如，假设一个浮点类型的值 \(v\)可以用确定的\(s,m,e\) 表示成这种形式，恰好其中\(m\)是偶数，\(e\)小于\(2^{K-1}\)， 则可以产生该值的另一种表示方式：\(m\)减半，\(e\)增加1。</p>
<p>如果\(m \ge 2^{N-1}\)，这种形式的表示称为<em>normalized</em>；否则，被称为<em>subnormal</em>。如果一个浮点类型的值不能够以\(m \ge 2^{N-1}\)这种形式表示，则称该值为非规格数(<a href="https://en.wikipedia.org/wiki/Subnormal_number"><em>subnormal number</em></a>)，因为它的绝对值（magnitude）低于最小的规格数（normalized value）。(译者注：具体的术语参考<a href="https://en.wikipedia.org/wiki/IEEE_754">wiki</a>，这里翻译来自https://www.jianshu.com/p/43b1b09f27f4)</p>
<p><code>float</code>和<code>double</code>中\(N\) 和 \(K\) 参数的约束（以及有它们衍生的 \(E_{min}\) 和 \(E_{max}\)）总结在<a href="chap02/primitive_type.html#floating-point-parameters">表2.3.2-A</a>中：</p>
<table width="60%" >
  <caption> <id id="floating-point-parameters">表2.3.2-A. 浮点数参数</id> </caption>
  <tr>
    <th>参数</th>
    <th><code>float</code></th>
    <th><code>double</code></th>
  </tr>
  <tr align="center">
    <td><math><mi>N</mi></math></td>
    <td>24</td>
    <td>53</td>
  </tr>
  <tr align="center">
    <td><math><mi>K</mi></math></td>
    <td>8</td>
    <td>11</td>
  </tr>
  <tr align="center">
    <td>
    <math>
      <msub>
        <mi>E</mi>
        <mrow>
          <mi>m</mi>
          <mi>a</mi>
          <mi>x</mi>
        </mrow>
      </msub>
    </math>
    </td>
    <td>+127</td>
    <td>+1023</td>
  </tr>
  <tr align="center">
    <td>
    <math>
      <msub>
        <mi>E</mi>
        <mrow>
          <mi>m</mi>
          <mi>i</mi>
          <mi>n</mi>
        </mrow>
      </msub>
    </math>
    </td>
    <td>-126</td>
    <td>-1022</td>
  </tr>
</table>
<p>除了NaN，浮点值是有序的（<em>ordered</em>）。从小到大进行排列，分别是负无穷，负有限非零值，正零和负零，正有限非零值，正无穷。</p>
<p>IEEE 754允许它的binary32和binary64浮点格式有多个不同格式的NaN。然而，Java SE平台通常将一个给定的浮点类型的NaN值看作为一个单一的规范值（a single canonical value），因此，该规范通常引用任意NaN，就像引用一个规范值。</p>
<blockquote>
<p>在IEEE 754下，用non-NaN参数进行浮点操作可能会产生NaN结果。IEEE 754指定了一组NaN位模式，但没有强制要求哪个特定的NaN位模式被用来表示NaN结果；这是留给了硬件体系结构。程序员可以创建具有不同位模式的NaN编码，例如，回溯性诊断信息（<em>A programmer can create NaNs with different bit patterns to
encode, for example, retrospective diagnostic information.</em>）。这些NaN值可以是使用<code>Float.intBitsToFloat</code>和<code>Double.longBitsToDouble</code>创建，<code>float</code>对应<code>Float.intBitsToFloat</code>，<code>double</code>对应<code>Double.longBitsToDouble</code>。相反，要检查NaN值的位模式，<code>float</code>和<code>double</code>类型可以分别使用<code>Float.floatToRawIntBits</code>和<code>Double.doubleToRawLongBits</code>方法。</p>
</blockquote>
<p>正0和负0比较起来是相等的，但是还有其他的运算可以区分它们；例如，用1.0除以0.0得到正无穷，但是用1.0除以-0.0得到负无穷。</p>
<p>NaN是无序的（<em>unordered</em>），因此，如果操作数有一个或两个都是NaN，数值比较和数值相等的测试都为<code>false</code>。特别的，数值相等性测试中值与自身的数值相等的结果为<code>false</code>，当且仅当该值为NaN。数值的不等性测试中，如果任何一个操作数是NaN，测试结果为<code>true</code>。</p>
<h3 id="returnaddress类型和值"><a class="header" href="#returnaddress类型和值"><code>returnAddress</code>类型和值</a></h3>
<p><code>returnAddress</code>类型被用于Java虚拟机的<em>jsr</em>、<em>ret</em>和<em>jsr_w</em>指令(<em>§jsr、§ret、§jsr_w</em>)。<code>returnAddress</code>类型的值是指向Java虚拟机指令操作码的指针。不像数字型的原子类型，<code>returnAddress</code>类型没有和Java编程语言的任何类型相对应，而且不能够被正在运行的程序修改。</p>
<h3 id="boolean类型"><a class="header" href="#boolean类型"><code>boolean</code>类型</a></h3>
<p>虽然 Java 虚拟机定义了<code>boolean</code>类型，但提供给其的支持非常有限。 没有单独的 Java 虚拟机指令专用于对布尔值的操作。 相反，Java 编程语言中操作在<code>boolean</code>值上的表达式会被编译成使用Java虚拟机的<code>int</code>数据类型。</p>
<p>Java 虚拟机确实直接支持<code>boolean</code>数组。 它的<code>newarray</code>指令（<em>§newarray</em>）允许创建<code>boolean</code>数组。 <code>boolean</code>类型的数组可以使用<code>byte</code>数组的<em>baload</em>和<em>bastore</em>指令来实现访问和修改（<em>§baload, §bastore</em>）。</p>
<blockquote>
<p>在 Oracle 的 Java 虚拟机实现中，Java编程语言的<code>boolean</code>数组被编码成Java虚拟机的<code>byte</code>数组，每个<code>boolean</code>元素使用8位（8 bits）来表示。</p>
</blockquote>
<p>Java虚拟机对<code>boolean</code>数组进行编码时，使用1表示<code>true</code>，使用0表示<code>false</code>。Java编程语言<code>boolean</code>值被编译器映射到Java虚拟机的<code>int</code>类型的地方，编译器必须使用相同的编码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用类型"><a class="header" href="#引用类型">引用类型</a></h1>
<p>有三种引用（<em>reference</em>）类型：类类型、数组类型和接口类型。相对应的，它们的值是对动态创建的类实例、或实现接口的类实例或者数组的引用。</p>
<p>数组类型由具有单一维度的组件类型（<em>component type</em>）组成(其长度不是由类型给出的)。数组类型的组件类型本身可以是数组类型。如果，从任何数组类型开始，考虑其组件类型，然后是该类型（如果它也是一个数组类型）的组件类型，等等，最终必须到达组件类型不是数组类型；这个类型则叫做数组的元素类型（<em>element type</em>）。数组类型的元素类型必须是原子类型，或者类类型，或这接口类型。</p>
<p>引用值（reference value）也可以是特殊的空引用（null reference），这个引用没有对象（a reference to no object），这里用<code>null</code>表示。空引用最初没有运行时类型，但可以转换为任何类型。<code>reference</code>类型的默认值为<code>null</code>。</p>
<p>此规范不强制要求将<code>null</code>编码为一个特定的值。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="运行时数据区域"><a class="header" href="#运行时数据区域">运行时数据区域</a></h2>
<p>Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。其中一些数据区域是在Java虚拟机启动时创建的，只有在Java虚拟机退出时才会销毁。其他数据区域是属于单个线程的。单个线程的数据区域在线程创建时创建，在线程退出时销毁。</p>
<h3 id="pc寄存器"><a class="header" href="#pc寄存器"><code>pc</code>寄存器</a></h3>
<p>Java虚拟机可以一次支持许多执行线程（JLS§17）。每个 Java虚拟机线程都有自己的<code>PC</code>（程序计数器）寄存器。在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法（§2.6）。如果该方法不是<code>native</code>方法，则<code>PC</code>寄存器包含当前正在执行的Java虚拟机指令的地址。如果当前由线程执行的方法是<code>native</code>方法，则Java 虚拟机的<code>PC</code>寄存器的值是未定义的。Java 虚拟机的<code>PC</code>寄存器足够宽，可以在特定平台上容纳<code>returnAddress</code>或者原生指针（native pointer）。</p>
<h3 id="java-虚拟机栈"><a class="header" href="#java-虚拟机栈">Java 虚拟机栈</a></h3>
<p>每个 Java 虚拟机线程都有一个私有的 Java 虚拟机堆栈（<em>Java Virtual Machine stack</em>），该虚拟机栈与线程同时创建。一个Java虚拟机栈存储着帧（frames）(§2.6)。Java虚拟机栈类似于传统语言如 C 语言的栈；它保存局部变量和部分结果，并在方法的调用和返回时发挥作用。因为除了对帧的 push 和 pop 操作外，Java 虚拟机栈永远不会被直接操作，所以帧可以在堆上分配。Java 虚拟机栈的内存不需要连续。</p>
<blockquote>
<p>在第一版的 Java 虚拟机规范中，Java 虚拟机栈（Java Virtual Machine stack）被称为 Java 栈（<em>Java stack</em>）。</p>
</blockquote>
<p>该规范允许 Java 虚拟机栈具有固定的大小，或者根据计算的需要动态地扩展和收缩。如果 Java 虚拟机栈的大小是固定的，则每个 Java 虚拟机栈的大小可以在创建该栈时独立选择。</p>
<blockquote>
<p>Java 虚拟机实现可以让程序员或用户控制 Java 虚拟机栈的初始大小，在动态扩展或收缩 Java 虚拟机栈的情况下，还可以控制最大和最小容量。</p>
</blockquote>
<p>以下是与 Java 虚拟机栈相关的异常条件:</p>
<ul>
<li>如果线程中的运算需要的 Java 虚拟机栈的空间超出允许的空间，Java 虚拟机将抛<code>StackOverflowError</code>。</li>
<li>如果 Java 虚拟机栈可以动态地扩展，且扩展时内存不足而影响到了扩展，或者内存不足以创建一个新线程的初始 Java 虚拟机栈，Java 虚拟机抛出一个<code>OutOfMemoryError</code>。</li>
</ul>
<h3 id="堆"><a class="header" href="#堆">堆</a></h3>
<p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的堆（<em>heap</em>）。堆是分配所有类实例和数组的内存的运行时数据区域。</p>
<p>堆是在虚拟机启动时创建的。对象的堆存储空间由自动存储管理系统（称为垃圾收集器<em>garbage collector</em>）回收；对象从来不会被显式地回收。 Java 虚拟机不假定自动存储管理系统的特定类型，并且可以根据实现者的系统要求选择存储管理技术。堆可能具有固定尺寸，也可以按计算的要求扩展，如果不需要较大的堆，则可能会收缩。堆的内存不需要连续。</p>
<blockquote>
<p>Java 虚拟机实现可以提供给程序员或用户控制堆的初始大小，以及如果可以动态扩展或收缩堆，则可以控制最大和最小堆大小的功能。</p>
</blockquote>
<p>以下异常条件与堆相关联：</p>
<ul>
<li>如果计算需要的堆内存大小比自动存储管理系统所能提供的更多，则 Java 虚拟机会抛出<code>OutofMemoryError</code>。</li>
</ul>
<h3 id="方法区"><a class="header" href="#方法区">方法区</a></h3>
<p>Java 虚拟机有一个方法区（<em>method area</em>），该方法区在所有 Java 虚拟机线程中共享。该方法区类似于通常所说的编程语言的编译代码的存储区域或类似于操作系统进程中的<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E6%AE%B5">代码段</a>（“text&quot; segment）。它存储了每个类结构，例如运行时常量池，成员变量（field）和方法数据以及方法和构造函数的代码，包括类和接口初始化以及实例初始化中使用的特殊方法（§2.9）。</p>
<p>方法区是在虚拟机启动时创建的。尽管方法区在逻辑上是堆（heap）的一部分，但简单的实现可能会选择不对该区域进行垃圾收集或压缩该区域（may choose not to either garbage collect or compact it）。该规范不要求方法区的位置或用于管理编译代码的策略。方法区可以具有固定大小，也可以根据计算的要求进行扩展，如果不需要较大的方法区域，则可能会收缩。方法区的内存不需要连续。</p>
<blockquote>
<p>Java 虚拟机的实现可以提供给程序员或用户对方法区初始大小的控制，以及在不同大小的方法区的情况下，控制最大和最小方法区大小的功能。</p>
</blockquote>
<p>以下异常条件与方法区相关联：</p>
<ul>
<li>如果方法去中的内存无法满足分配需求，则 Java 虚拟机将抛出<code>OutOfMemoryError</code>。</li>
</ul>
<h3 id="运行时常量池"><a class="header" href="#运行时常量池">运行时常量池</a></h3>
<p>运行时常量池（<em>run-time constant pool</em>）是每一个类或者接口的<code>class</code>文件中的<code>constant_pool</code>表的运行时表示（第4.4节）。它包含多种类型的常量，从编译时已知的数字常量到必须在运行时必须决定的方法和成员变量的引用。运行时常量池具有类似于常规编程语言的符号表的函数，但它包含的数据范围比典型的符号表更宽泛。</p>
<p>每个运行时常量池都是从 Java 虚拟机的方法区（§2.5.4）分配的。当 Java 虚拟机创建类或接口（§5.3）时，会创建类或接口的运行时常量池。</p>
<p>以下异常条件与类或接口的运行时常量池的创建有关：</p>
<ul>
<li>创建类或接口时，如果运行时常量池的创建需要的内存大于 Java 虚拟机的方法区域的可用的内存，则 Java 虚拟机将抛出 <code>OutOfMemoryError</code>。</li>
</ul>
<blockquote>
<p>有关运行时常量池的创建的信息，请参见§5（加载，链接和初始化）。</p>
</blockquote>
<h3 id="本地方法栈"><a class="header" href="#本地方法栈">本地方法栈</a></h3>
<p>Java 虚拟机的实现可以使用常规的栈，称为“ C 栈”，以支持本地（native）方法（用Java编程语言以外的其他语言编写的方法）。本地方法栈也可以被用于 Java 虚拟机指令集解释器的实现的语言中，如 C 语言。不能加载<code>native</code>方法和不依赖于传统的栈的 Java 虚拟机实现没有必要提供本地方法栈。如果提供，当创建每个线程时，通常会分配本地方法栈。（An implementation of the Java Virtual Machine may use conventional stacks, colloquially called &quot;C stacks,&quot; to support native methods (methods written in a language other than the Java programming language). Native method stacks may also be used by the implementation of an interpreter for the Java Virtual Machine's instruction set in a language such as C. Java Virtual Machine implementations that cannot load native methods and that do not themselves rely on conventional stacks need not supply native method stacks. If supplied, native method stacks are typically allocated per thread when each thread is created.）</p>
<p>该规范允许本地方法栈可以是固定大小，或者根据计算的要求动态扩展和收缩。如果本地方法栈的大小为固定大小，则在创建该栈时，可以独立选择每个本地方法栈的大小。</p>
<blockquote>
<p>Java 虚拟机实现可以提供给程序员或用户对本地方法栈初始大小的控制，以及在本地方法栈大小变动的情况下，可以控制最大和最小方法栈大小的功能。</p>
</blockquote>
<p>以下异常条件与本地方法栈相关联：</p>
<ul>
<li>如果线程中的计算需要的本地方法栈比允许的更大，Java 虚拟机将抛出<code>StackOverflowError</code>。</li>
<li>如果可以动态地扩展本地方法栈，并且尝试进行本地方法栈扩展，但是内存不足，或者没有足够的内存为新线程创建初始的本地方法堆栈，那么 Java 虚拟机将抛出<code>OutOfMemoryError</code>。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
