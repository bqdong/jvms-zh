<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JVM Specification (Java SE 17 Edition) Chinese Translation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="chap02/structure_of_jvm.html"><strong aria-hidden="true">2.</strong> JVM的结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chap02/class_file_format.html"><strong aria-hidden="true">2.1.</strong> class文件格式</a></li><li class="chapter-item expanded "><a href="chap02/data_type.html"><strong aria-hidden="true">2.2.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="chap02/primitive_type.html"><strong aria-hidden="true">2.3.</strong> 原子类型</a></li><li class="chapter-item expanded "><a href="chap02/reference_type.html"><strong aria-hidden="true">2.4.</strong> 引用类型</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JVM Specification (Java SE 17 Edition) Chinese Translation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第一章-介绍"><a class="header" href="#第一章-介绍">第一章 介绍</a></h1>
<h2 id="历史"><a class="header" href="#历史">历史</a></h2>
<p>Java编程语言是一种通用的、并发的、面向对象的语言语言。它的语法类似于C和C++，但它省去了许多使C和C++变得复杂、混乱和不安全的特性。Java平台被开发，最初是用于解决构建网络设备的软件的问题。它被设计为支持多主机架构，并允许软件组件的安全交付。为了满足这些要求，编译后的代码必须满足要在跨网络传输中存活，在任何客户端上操作，并确保客户端是安全运行的目标。</p>
<p>万维网的普及使这些特性更加明显有趣。网络浏览器使数百万人能够以简单的方式上网并且访问丰富的媒体内容。终于有了一种媒介不管你使用的是哪种机器，无论连接的是快速的网络还是慢的调制解调器，看到和听到的内容基本上是相同的。</p>
<p>Web爱好者很快就发现了由Web的HTML所支持的内容文档格式太有限。HTML扩展，比如表单强调了这些限制，同时明确指出没有浏览器可以包含所有用户想要的功能。可扩展性是答案。</p>
<p><a href="https://zh.wikipedia.org/wiki/HotJava">HotJava</a>浏览器首先展示了Java编程语言和平台使程序嵌入在HTML页面成为可能的有趣的特性（译者注：<a href="https://zh.wikipedia.org/wiki/Java_applet">Java Applet</a>）。程序和HTML页面被透明地下载到浏览器中，并且呈现在HTML页面中。在被浏览器接受之前，程序被仔细检查，以确保是安全的。像HTML页面，编译后的程序是独立于网络和主机的。这些程序不管来自哪里或使用哪种机器加载和运行，它们都表现出相同的行为。</p>
<p>与Java平台结合的Web浏览器不再局限于预先确定的功能集。访问者访问包含动态内容的网页可以确保其机器不会被该内容损坏。程序员只需要编写一次程序，就可以在任何提供Java运行时环境的机器上运行（译者注：Write once, run anywhere）。</p>
<h2 id="java虚拟机"><a class="header" href="#java虚拟机">Java虚拟机</a></h2>
<p>Java虚拟机是Java平台的基石。这是负责硬件和操作系统独立性的技术组件，其编译代码的体积小，且具有保护用户免受恶意程序的侵害的能力。</p>
<p>Java虚拟机是一个抽象的计算机。就像真正的计算一样机器，它有一个指令集，并在运行时操作各种内存区域。使用虚拟机来实现编程语言是相当常见的；最著名的虚拟机可能是<a href="https://zh.wikipedia.org/wiki/UCSD_Pascal">UCSD Pascal</a> 的 <a href="https://zh.wikipedia.org/wiki/P-code%E6%9C%BA">P-Code</a>虚拟机。</p>
<p>Java虚拟机的第一个原型实现，在 <a href="https://zh.wikipedia.org/wiki/%E6%98%87%E9%99%BD%E9%9B%BB%E8%85%A6">Sun Microsystems</a>公司完成， 在软件中模拟了Java虚拟机指令集，该软件由一个类似于当代个人数码设备(<a href="https://zh.wikipedia.org/wiki/%E4%B8%AA%E4%BA%BA%E6%95%B0%E7%A0%81%E5%8A%A9%E7%90%86">PDA</a>)的手持设备托管。Oracle当前的实现模拟了Java虚拟机在移动端，桌面端和服务器端的设备，但Java虚拟机不限定（not assume）任何特定的实现技术、主机硬件或主机操作系统。它不是固有的解释型的（ It is not inherently interpreted），但也可以通过将其指令集编译为处理器（silicon CPU）的指令集来实现。也可能可以在微指令（<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E7%A8%8B%E5%BA%8F">microcode</a>）或者硬件（silicon）中实现。</p>
<p>Java虚拟机对Java编程语言一无所知，仅针对特定的二进制格式，<code>class</code>文件格式。其中<code>class</code>文件包含Java虚拟机指令(或字节码(<em>bytecodes</em>))和符号表等辅助信息。</p>
<p>为了安全起见，对于<code>class</code>文件的代码，Java虚拟机引入了强大的语法和结构约束。然而，任何可以通过合法的<code>class</code>文件表示功能的语言都可以被托管到Java虚拟机（hosted by)。被一种普遍可用的、与机器无关的平台的特性所吸引的开发者，都可以转向Java虚拟机，将其作为他们语言的传递工具（Groovy，Kotlin）。</p>
<p>这里指定的Java虚拟机与Java SE 17平台兼容，并支持 <a href="https://docs.oracle.com/javase/specs/jls/se17/html/index.html"><em>The Java Language Specification, Java SE 17 Edition</em></a>中指定的Java编程语言。</p>
<h2 id="内容组织"><a class="header" href="#内容组织">内容组织</a></h2>
<p>第2章概述了Java虚拟机架构。</p>
<p>第3章介绍了用Java编程语言编写的代码编译成Java虚拟机指令的过程。</p>
<p>第4章具体说明与硬件和操作系统无关用于表示已编译类和接口的二进制格式的<code>class</code>文件格式。</p>
<p>第5章具体说明Java虚拟机的启动，加载、链接和初始化类和接口。</p>
<p>第6章具体说明Java虚拟机的指令集，以操作码助记符的字母顺序来展示指令。</p>
<p>第7章给出了一个以操作码值为索引的Java虚拟机操作码助记符表。</p>
<p>在第二版的<em>Java Virtual Machine Specification</em>，第2章概述了 Java 编程语言，旨在支持
Java 虚拟机规范，但它本身并不是规范的一部分。在<em>Java Virtual Machine Specification, Java SE 17 Edition</em>（译者注：也就是本手册）中，请读者参阅<a href="https://docs.oracle.com/javase/specs/jls/se17/html/index.html"><em>The Java Language Specification, Java SE 17 Edition</em></a>来查询Java编程语言相关信息。引用的格式：(JLS§x.y)指出需要这样做的地方。</p>
<p>在第二版的Java虚拟机规范，第8章详细解释了具有共享主存的Java虚拟机线程交互的底层操作。在<em>Java Virtual Machine Specification, Java SE 17 Edition</em>中，读者可以参考<a href="https://docs.oracle.com/javase/specs/jls/se17/html/index.html"><em>The Java Language Specification, Java SE 17 Edition</em></a>的第17章有关线程和锁的信息。第17章反映了出自于JSR133专家组的<a href="https://www.cs.umd.edu/%7Epugh/java/memoryModel/jsr133.pdf">The Java Memory Model and Thread Specification</a>。</p>
<h2 id="符号"><a class="header" href="#符号">符号</a></h2>
<p>在整个规范中，我们指出的类和接口取自Java SE平台API。当我们引用一个类或接口时(除了那些声明在示例中的)，使用单个标识符<em>N</em>，其指的是<code>java.lang</code>包中的类或接口。在<code>java.lang</code>包以外的类或者接口，我们使用全限定名（fully qualified name）来指明。</p>
<p>每当我们引用一声明在<code>java</code>或它的任何子包中的类或者接口时，预期的引用是那个类或者接口被启动类加载器加载(<a href="https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-5.html#jvms-5.3.1">§5.3.1</a>)。</p>
<p>每当我们引用一个名为<code>java</code>的包的子包时，预期的引用是由启动类装加载器决定的。</p>
<p>本规范中字体的使用如下:</p>
<ul>
<li><code>等宽</code>字体用于Java虚拟机数据类型、异常、错误、<code>class</code>文件结构、<a href="https://zh.wikipedia.org/wiki/Prolog">Prolog</a>代码和Java代码片段。</li>
<li><em>斜体</em>是用于Java虚拟机的“汇编语言”，其操作码和操作数，以及Java虚拟机的运行时数据区域中的项。它也用于介绍新的术语和简单的强调。</li>
</ul>
<p>非规范性信息，旨在澄清规范，使用以下格式表示：</p>
<blockquote>
<p>这是非规范性信息。 它提供直觉、基本原理、建议、示例等。</p>
</blockquote>
<h2 id="反馈"><a class="header" href="#反馈">反馈</a></h2>
<p>读者可以报告<em>Java Virtual Machine Specification</em>中的技术错误和歧义，反馈至jls-jvms-spec-comments@openjdk.java.net（译者注：由于译者水平有限，此翻译可能存在不准确，反馈时请自行阅读原版规范确定无误后再反馈）。</p>
<p>关于<code>javac</code>（Java编程语言的参考编译器）生成和操作<code>class</code>文件的问题可以发送到compilerdev@openjdk.java.net（译者注：由于译者水平有限，此翻译可能存在不准确，反馈时请自行阅读原版规范确定无误后再反馈）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jvm的结构"><a class="header" href="#jvm的结构">JVM的结构</a></h1>
<p>这个文档具体说明了一个抽象机器。它没有描述任何特定的Java虚拟机的实现。</p>
<p>要正确实现Java虚拟机，您只需要能够读取<code>class</code>文件格式并正确执行其中指定的操作。不属于Java虚拟机规范的实现细节没必要限制实现者的创造力。例如，运行时数据区域的内存布局、使用的垃圾收集算法以及任何Java虚拟机指令的内部优化(例如，将它们翻译成机器代码)是由实现者决定的。</p>
<p>本规范中对Unicode的所有引用都是关于<em>The Unicode Standard, Version 13.0</em>，可在 https://www.unicode.org/ 获得。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="class文件格式"><a class="header" href="#class文件格式"><code>class</code>文件格式</a></h2>
<p>由 Java 虚拟机执行的编译代码表示为一种独立于硬件和操作系统的二进制格式，通常（但不是必须）存储在一个文件中，称为<code>class</code>文件格式。 <code>class</code>文件格式精确定义类或接口的表示，包括细节，例如在特定于平台的目标文件中可能被视为理所当然的字节顺序（<a href="https://en.wikipedia.org/wiki/Endianness">Byte Ordering</a>）。</p>
<p>第 4 章，”<code>class</code>文件格式“，详细介绍了<code>class</code>文件格式。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<p>与 Java 编程语言一样，Java 虚拟机在两种类型上进行操作：<em>原子类型（primitive types）<em>和</em>引用类型（reference types）</em>。相应地，有两种类型的值可以被存储在变量中，作为参数传递，作为方法返回值被返回，并可以对其进行操作：<em>原子类型的值（primitive values）<em>和</em>引用类型的值（reference values）</em>。</p>
<p>Java 虚拟机期望几乎所有类型检查都在运行前完成，通常这是由编译器完成的，而不必由 Java 完成虚拟机本身完成。原子类型的值不需要被标记（tagged）或以其他方式检查以确定它们在运行时的类型，或与引用类型的值进行区分。取而代之的是Java虚拟机的使用那些操作在特定类型上的指令来区分操作数类型。例如，<em>iadd</em>、<em>ladd</em>、<em>fadd</em> 和 <em>dadd</em> 都是 Java 虚拟机将两个数值相加并产生数值结果的指令，但每一个都是专门针对其操作数类型：分别为<code> int</code>、<code>long</code>、<code>float</code> 和 <code>double</code>。对于Java虚拟机指令集支持的类型的总结，请参阅 §2.11.1。</p>
<p>Java 虚拟机包含对对象的显式支持。一个对象是动态分配的类实例或数组。对对象的引用被认为时 Java 虚拟机引用（<code>reference</code>）类型。<code>reference</code>类型的值可以被认为是指向对象的指针。总是通过<code>reference</code>类型的值来操作、传递和测试对象。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="原子类型"><a class="header" href="#原子类型">原子类型</a></h2>
<p>Java 虚拟机支持的原子数据类型是数字类型（<em>numeric types</em>）、布尔类型(<code>boolean</code> type)（第 2.3.4 节）和 <code>returnAddress</code> 类型（第 2.3.3 节）。</p>
<p>数字类型由整数类型（<em>integral types</em>）（第 2.3.1 节）和浮点类型（<em>floating-point types</em>）组成（§2.3.2）。</p>
<p>整数类型包括：</p>
<ul>
<li><code>byte</code>，它的值时8位有符号二进制补码整数，默认值为0。</li>
<li><code>short</code>，它的值时16位有符号二进制补码整数，默认值为0。</li>
<li><code>int</code>，它的值时32位有符号二进制补码整数，默认值为0。</li>
<li><code>long</code>，它的值时64位有符号二进制补码整数，默认值为0。</li>
<li><code>char</code>，它的值时16位<strong>无符号</strong>整数表示的在<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2">基本多文种平面</a>Unicode码点（code point），使用UTF-16编码，默认值是空码点（<code>\u0000</code>）。</li>
</ul>
<p>浮点类型包括：</p>
<ul>
<li><code>float</code>它的值与<a href="https://en.wikipedia.org/wiki/IEEE_754#Basic_and_interchange_formats">IEEE 754 binary32</a>格式的相对应，默认值是<strong>正数0</strong>（+0）</li>
<li><code>double</code>，它的值与<a href="https://en.wikipedia.org/wiki/IEEE_754#Basic_and_interchange_formats">IEEE 754 binary64</a>格式的相对应，默认值是<strong>正数0</strong>（+0）</li>
</ul>
<p><code>boolean</code>类型的值编码真值是<code>true</code>和<code>false</code>，默认值是<code>false</code>。</p>
<blockquote>
<p>第一版的<em>The Java Virtual Machine Specification</em>没有将<code>boolean</code>类型视为一种Java虚拟机类型。然而，<code>boolean</code>值在Java虚拟机中有受限的支持。第二版的<em>The Java Virtual Machine Specification</em>将<code>boolean</code>视为一种类型来阐明这个问题。</p>
</blockquote>
<p><code>returnAddress</code> 类型的值是指向 Java虚拟机指令的操作码的指针。 在原子类型中，只有 <code>returnAddress</code> 类型不是直接与 Java 编程语言类型相关联。</p>
<h3 id="整数类型和值"><a class="header" href="#整数类型和值">整数类型和值</a></h3>
<p>Java虚拟机的整数类型的值为：</p>
<ul>
<li>对于<code>byte</code>，范围为-128~127（\(-2^7\)~\(2^7-1\)），包含-128和127</li>
<li>对于<code>short</code>，范围为-32768~32767（\(-2^15\)~\(2^15-1\)），包含-32768和32767</li>
<li>对于<code>int</code>，范围为-2147483648 ~2147483647（\(-2^31\)~\(2^31-1\)），包含-2147483648和2147483647</li>
<li>对于<code>long</code>，范围为-9223372036854775808~9223372036854775807（\(-2^63\)~\(2^63-1\)），包含-9223372036854775808和9223372036854775807</li>
<li>对于<code>char</code>，范围为0~65535，包含0和65535</li>
</ul>
<h3 id="浮点类型和值"><a class="header" href="#浮点类型和值">浮点类型和值</a></h3>
<p>浮点类型有<code>float</code>和<code>double</code>，它们在概念上分别和IEEE 754 中的32位binary32和64位binary64浮点数格式的值和操作相关联(JLS§1.7)。</p>
<blockquote>
<p>在Java SE 15及之后的版本中，Java虚拟机使用IEEE 754的2019版标准。在Java SE 15之前，Java虚拟机使用的是1985版的IEEE  754标准，其中binary32格式被称为单精度（single format），binary64格式被称为双精度（double format）。</p>
</blockquote>
<p>IEEE 754不仅包括由符号和绝对值（<a href="https://simple.wikipedia.org/wiki/Magnitude_(mathematics)#:%7E:text=The%20magnitude%20of%20a%20real%20number%20is%20usually,absolute%20value%20or%20modulus.%20It%20is%20written%20as"><em>magnitude</em></a>）组成的正数和负数，还有正零和负零，正无穷大和负无穷大(<em>infinities</em>)，和特殊的非数值的值(Not-a-Number)(以下简称NaN)。NaN值为用于表示某些无效运算的结果，如0除以0。<code>float</code>和<code>double</code>类型的NaN常量被预定义为<code>Float.NaN</code>和<code>Double.NaN</code>。</p>
<p>有限的非零的浮点数类型的值可以被表示为\(s\cdot m \cdot 2^{(e-N+1)}\) ，这里的：</p>
<ul>
<li>\(s\) 是 +1 或者 -1，</li>
<li>\(m\) 是一个小于 \(2^N\) 的正整数，</li>
<li>\(e\) 是一个整数，满足\(E_{min}\le e \le E_{max}\) ，其中 \(E_{min}=-(2^{K-1}-2)\) ，\(E_{max}=2^{K-1}-1\) ，</li>
<li>\(N\) 和 \(K\) 是依赖于类型的参数</li>
</ul>
<p>有些值可以以多种方式表示为这种形式。例如，假设一个浮点类型的值 \(v\)可以用确定的\(s,m,e\) 表示成这种形式，恰好其中\(m\)是偶数，\(e\)小于\(2^{K-1}\)， 则可以产生该值的另一种表示方式：\(m\)减半，\(e\)增加1。</p>
<p>如果\(m \ge 2^{N-1}\)，这种形式的表示称为<em>normalized</em>；否则，被称为<em>subnormal</em>。如果一个浮点类型的值不能够以\(m \ge 2^{N-1}\)这种形式表示，则称该值为非规格数(<a href="https://en.wikipedia.org/wiki/Subnormal_number"><em>subnormal number</em></a>)，因为它的绝对值（magnitude）低于最小的规格数（normalized value）。(译者注：具体的术语参考<a href="https://en.wikipedia.org/wiki/IEEE_754">wiki</a>，这里翻译来自https://www.jianshu.com/p/43b1b09f27f4)</p>
<p><code>float</code>和<code>double</code>中\(N\) 和 \(K\) 参数的约束（以及有它们衍生的 \(E_{min}\) 和 \(E_{max}\)）总结在<a href="chap02/primitive_type.html#floating-point-parameters">表2.3.2-A</a>中：</p>
<table width="60%" >
  <caption> <id id="floating-point-parameters">表2.3.2-A. 浮点数参数</id> </caption>
  <tr>
    <th>参数</th>
    <th><code>float</code></th>
    <th><code>double</code></th>
  </tr>
  <tr align="center">
    <td><math><mi>N</mi></math></td>
    <td>24</td>
    <td>53</td>
  </tr>
  <tr align="center">
    <td><math><mi>K</mi></math></td>
    <td>8</td>
    <td>11</td>
  </tr>
  <tr align="center">
    <td>
    <math>
      <msub>
        <mi>E</mi>
        <mrow>
          <mi>m</mi>
          <mi>a</mi>
          <mi>x</mi>
        </mrow>
      </msub>
    </math>
    </td>
    <td>+127</td>
    <td>+1023</td>
  </tr>
  <tr align="center">
    <td>
    <math>
      <msub>
        <mi>E</mi>
        <mrow>
          <mi>m</mi>
          <mi>i</mi>
          <mi>n</mi>
        </mrow>
      </msub>
    </math>
    </td>
    <td>-126</td>
    <td>-1022</td>
  </tr>
</table>
<p>除了NaN，浮点值是有序的（<em>ordered</em>）。从小到大进行排列，分别是负无穷，负有限非零值，正零和负零，正有限非零值，正无穷。</p>
<p>IEEE 754允许它的binary32和binary64浮点格式有多个不同格式的NaN。然而，Java SE平台通常将一个给定的浮点类型的NaN值看作为一个单一的规范值（a single canonical value），因此，该规范通常引用任意NaN，就像引用一个规范值。</p>
<blockquote>
<p>在IEEE 754下，用non-NaN参数进行浮点操作可能会产生NaN结果。IEEE 754指定了一组NaN位模式，但没有强制要求哪个特定的NaN位模式被用来表示NaN结果；这是留给了硬件体系结构。程序员可以创建具有不同位模式的NaN编码，例如，回溯性诊断信息（<em>A programmer can create NaNs with different bit patterns to
encode, for example, retrospective diagnostic information.</em>）。这些NaN值可以是使用<code>Float.intBitsToFloat</code>和<code>Double.longBitsToDouble</code>创建，<code>float</code>对应<code>Float.intBitsToFloat</code>，<code>double</code>对应<code>Double.longBitsToDouble</code>。相反，要检查NaN值的位模式，<code>float</code>和<code>double</code>类型可以分别使用<code>Float.floatToRawIntBits</code>和<code>Double.doubleToRawLongBits</code>方法。</p>
</blockquote>
<p>正0和负0比较起来是相等的，但是还有其他的运算可以区分它们；例如，用1.0除以0.0得到正无穷，但是用1.0除以-0.0得到负无穷。</p>
<p>NaN是无序的（<em>unordered</em>），因此，如果操作数有一个或两个都是NaN，数值比较和数值相等的测试都为<code>false</code>。特别的，数值相等性测试中值与自身的数值相等的结果为<code>false</code>，当且仅当该值为NaN。数值的不等性测试中，如果任何一个操作数是NaN，测试结果为<code>true</code>。</p>
<h3 id="returnaddress类型和值"><a class="header" href="#returnaddress类型和值"><code>returnAddress</code>类型和值</a></h3>
<p><code>returnAddress</code>类型被用于Java虚拟机的<em>jsr</em>、<em>ret</em>和<em>jsr_w</em>指令(<em>§jsr、§ret、§jsr_w</em>)。<code>returnAddress</code>类型的值是指向Java虚拟机指令操作码的指针。不像数字型的原子类型，<code>returnAddress</code>类型没有和Java编程语言的任何类型相对应，而且不能够被正在运行的程序修改。</p>
<h3 id="boolean类型"><a class="header" href="#boolean类型"><code>boolean</code>类型</a></h3>
<p>虽然 Java 虚拟机定义了<code>boolean</code>类型，但提供给其的支持非常有限。 没有单独的 Java 虚拟机指令专用于对布尔值的操作。 相反，Java 编程语言中操作在<code>boolean</code>值上的表达式会被编译成使用Java虚拟机的<code>int</code>数据类型。</p>
<p>Java 虚拟机确实直接支持<code>boolean</code>数组。 它的<code>newarray</code>指令（<em>§newarray</em>）允许创建<code>boolean</code>数组。 <code>boolean</code>类型的数组可以使用<code>byte</code>数组的<em>baload</em>和<em>bastore</em>指令来实现访问和修改（<em>§baload, §bastore</em>）。</p>
<blockquote>
<p>在 Oracle 的 Java 虚拟机实现中，Java编程语言的<code>boolean</code>数组被编码成Java虚拟机的<code>byte</code>数组，每个<code>boolean</code>元素使用8位（8 bits）来表示。</p>
</blockquote>
<p>Java虚拟机对<code>boolean</code>数组进行编码时，使用1表示<code>true</code>，使用0表示<code>false</code>。Java编程语言<code>boolean</code>值被编译器映射到Java虚拟机的<code>int</code>类型的地方，编译器必须使用相同的编码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用类型"><a class="header" href="#引用类型">引用类型</a></h1>
<p>有三种引用（<em>reference</em>）类型：类类型、数组类型和接口类型。相对应的，它们的值是对动态创建的类实例、或实现接口的类实例或者数组的引用。</p>
<p>数组类型由具有单一维度的组件类型（<em>component type</em>）组成(其长度不是由类型给出的)。数组类型的组件类型本身可以是数组类型。如果，从任何数组类型开始，考虑其组件类型，然后是该类型（如果它也是一个数组类型）的组件类型，等等，最终必须到达组件类型不是数组类型；这个类型则叫做数组的元素类型（<em>element type</em>）。数组类型的元素类型必须是原子类型，或者类类型，或这接口类型。</p>
<p>引用值（reference value）也可以是特殊的空引用（null reference），这个引用没有对象（a reference to no object），这里用<code>null</code>表示。空引用最初没有运行时类型，但可以转换为任何类型。<code>reference</code>类型的默认值为<code>null</code>。</p>
<p>此规范不强制要求将<code>null</code>编码为一个特定的值。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
